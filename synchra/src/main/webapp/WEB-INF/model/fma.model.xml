<?xml version="1.0" encoding="utf-8" ?>

<model xmlns="http://www.top-logic.com/ns/dynamic-types/6.0">
	<module name="fma">
		<enum name="CompanyStructure">
			<classifier name="AG"/>
			<classifier name="GmbH"/>
			<classifier name="CoKG"/>
		</enum>
		<class name="Company">
			<generalizations>
				<generalization type="tl.model:TLObject"/>
			</generalizations>
			<attributes>
				<property name="name"
					mandatory="true"
					type="tl.core:String"
				/>
				<reference name="structure"
					kind="forwards"
					mandatory="true"
					navigate="true"
					type="CompanyStructure"
				/>
			</attributes>
		</class>
		<interface name="Component">
			<generalizations>
				<generalization type="tl.model:TLObject"/>
			</generalizations>
			<attributes>
				<property name="name"
					mandatory="true"
					type="tl.core:String"
				/>
				<reference name="used"
					inverse-reference="consistsOf"
					kind="backwards"
					multiple="true"
					navigate="true"
					type="Connection"
				/>
				<property name="price"
					type="tl.core:Double"
				/>
			</attributes>
		</interface>
		<class name="ConstructionGroup">
			<generalizations>
				<generalization type="Component"/>
			</generalizations>
			<attributes>
				<reference name="consistsOf"
					composite="true"
					inverse-reference="used"
					kind="forwards"
					multiple="true"
					navigate="true"
					type="Connection"
				>
					<annotations>
						<constraints>
							<constraint class="com.top_logic.model.util.NoAttributeCycle">
								<additional-observed-references>
									<additional-observed-reference name="consistsOf"
										definition="fma:Connection"
									/>
								</additional-observed-references>
							</constraint>
						</constraints>
					</annotations>
				</reference>
				<property name="price"
					override="true"
					type="tl.core:Double"
				>
					<annotations>
						<storage-algorithm>
							<query expr="grp -> $grp.get(`fma:ConstructionGroup#consistsOf`).get(`fma:Connection#consistsOf`).get(`fma:Component#price`).sum()"/>
						</storage-algorithm>
					</annotations>
				</property>
			</attributes>
		</class>
		<class name="SinglePart">
			<generalizations>
				<generalization type="Component"/>
			</generalizations>
			<attributes>
				<reference name="company"
					kind="forwards"
					navigate="true"
					type="Company"
				/>
				<reference name="material"
					kind="forwards"
					multiple="true"
					navigate="true"
					type="Material"
				/>
			</attributes>
		</class>
		<class name="ComponentNode">
			<generalizations>
				<generalization type="tl.model:TLObject"/>
			</generalizations>
			<attributes>
				<reference name="component"
					kind="forwards"
					mandatory="true"
					navigate="true"
					type="Component"
				/>
				<reference name="connection"
					kind="forwards"
					navigate="true"
					type="Connection"
				/>
				<reference name="parent"
					inverse-reference="children"
					kind="forwards"
					navigate="true"
					type="ComponentNode"
				/>
				<property name="name"
					type="tl.core:String"
				>
					<annotations>
						<storage-algorithm>
							<query expr="node -> $node.get(`fma:ComponentNode#component`).isEmpty() ?$node.get(`fma:ComponentNode#product`).get(`fma:Product#name`): $node.get(`fma:ComponentNode#component`).get(`fma:Component#name`)"/>
						</storage-algorithm>
					</annotations>
				</property>
				<reference name="product"
					kind="forwards"
					type="Product"
				/>
				<reference name="children"
					inverse-reference="parent"
					kind="backwards"
					multiple="true"
					navigate="true"
					type="ComponentNode"
				/>
				<property name="price"
					type="tl.core:Double"
				>
					<annotations>
						<storage-algorithm>
							<query>
								<expr><![CDATA[node -> if( $node.get(`fma:ComponentNode#component`).instanceOf(`fma:SinglePart`),
 $node.get(`fma:ComponentNode#component`).get(`fma:SinglePart#price`),
 $node.get(`fma:ComponentNode#children`).get(`fma:ComponentNode#price`).sum()
)]]></expr>
							</query>
						</storage-algorithm>
					</annotations>
				</property>
			</attributes>
		</class>
		<class name="Connection">
			<generalizations>
				<generalization type="tl.model:TLObject"/>
			</generalizations>
			<attributes>
				<reference name="used"
					aggregate="true"
					inverse-reference="consistsOf"
					kind="backwards"
					navigate="true"
					type="ConstructionGroup"
				/>
				<reference name="consistsOf"
					inverse-reference="used"
					kind="forwards"
					mandatory="true"
					navigate="true"
					type="Component"
				/>
				<property name="position"
					type="tl.core:String"
				/>
				<reference name="countries"
					kind="forwards"
					multiple="true"
					navigate="true"
					type="Country"
				/>
			</attributes>
		</class>
		<class name="Country">
			<generalizations>
				<generalization type="tl.model:TLObject"/>
			</generalizations>
			<attributes>
				<property name="name"
					mandatory="true"
					type="tl.core:String"
				/>
			</attributes>
		</class>
		<class name="Material">
			<generalizations>
				<generalization type="tl.model:TLObject"/>
			</generalizations>
			<attributes>
				<property name="name"
					mandatory="true"
					type="tl.core:String"
				/>
			</attributes>
		</class>
		<class name="PartCatalog">
			<generalizations>
				<generalization type="tl.model:TLObject"/>
			</generalizations>
			<attributes>
				<property name="name"
					mandatory="true"
					type="tl.core:String"
				/>
				<reference name="parts"
					composite="true"
					kind="forwards"
					multiple="true"
					navigate="true"
					type="SinglePart"
				/>
				<reference name="partGroups"
					kind="forwards"
					multiple="true"
					navigate="true"
					type="PartsGroup"
				>
					<annotations>
						<storage-algorithm>
							<query>
								<expr><![CDATA[catalog -> 
all(`fma:Company`).map( company -> 
        new(`fma:PartsGroup`, transient: true)
	..set(`fma:PartsGroup#name`, $company.get(`fma:Company#name`))
	..set(`fma:PartsGroup#parts`, 
	         $catalog.get(`fma:PartCatalog#parts`).filter(part -> $part.get(`fma:SinglePart#company`)==$company)
	       )  
)]]></expr>
							</query>
						</storage-algorithm>
						<create-visibility value="hidden"/>
						<visibility value="hidden"/>
					</annotations>
				</reference>
				<reference name="materialGroups"
					kind="forwards"
					multiple="true"
					navigate="true"
					type="PartsGroup"
				>
					<annotations>
						<storage-algorithm>
							<query>
								<expr><![CDATA[catalog -> 
all(`fma:Material`).map( material -> 
        new(`fma:PartsGroup`, transient: true)
	..set(`fma:PartsGroup#name`, $material.get(`fma:Material#name`))
	..set(`fma:PartsGroup#parts`, 
	         $catalog.get(`fma:PartCatalog#parts`).filter(part -> $part.get(`fma:SinglePart#material`).containsElement($material))
	       )  
)
]]></expr>
							</query>
						</storage-algorithm>
						<create-visibility value="hidden"/>
						<visibility value="hidden"/>
					</annotations>
				</reference>
				<reference name="materialCompany"
					kind="forwards"
					multiple="true"
					navigate="true"
					type="PartsGroup"
				>
					<annotations>
						<storage-algorithm>
							<query>
								<expr><![CDATA[catalog -> 
all(`fma:Company`).map( company -> 
    new(`fma:PartsGroup`, transient: true)
	  ..set(`fma:PartsGroup#name`, $company.get(`fma:Company#name`))
	  ..set(`fma:PartsGroup#parts`,      
		  all(`fma:Material`).map( material -> 
	         new(`fma:PartsGroup`, transient: true)
		       ..set(`fma:PartsGroup#name`, $material.get(`fma:Material#name`))
		       ..set(`fma:PartsGroup#parts`, 
		         $catalog.get(`fma:PartCatalog#parts`).filter(
		        	 part -> $part.get(`fma:SinglePart#material`).containsElement($material) && $part.get(`fma:SinglePart#company`)==$company
		        )
		   )  
	    ) 
     )
)]]></expr>
							</query>
						</storage-algorithm>
						<create-visibility value="hidden"/>
						<visibility value="hidden"/>
					</annotations>
				</reference>
			</attributes>
		</class>
		<class name="PartsGroup">
			<generalizations>
				<generalization type="tl.model:TLObject"/>
			</generalizations>
			<attributes>
				<property name="name"
					type="tl.core:String"
				/>
				<reference name="parts"
					kind="forwards"
					multiple="true"
					navigate="true"
					type="tl.model:TLObject"
				/>
			</attributes>
		</class>
		<class name="Product">
			<generalizations>
				<generalization type="tl.model:TLObject"/>
			</generalizations>
			<attributes>
				<reference name="buildGroup"
					composite="true"
					kind="forwards"
					mandatory="true"
					navigate="true"
					type="ConstructionGroup"
				/>
				<property name="name"
					mandatory="true"
					type="tl.core:String"
				/>
			</attributes>
		</class>
	</module>
</model>